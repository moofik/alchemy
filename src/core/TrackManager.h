#pragma once
#include <vector>
#include <memory>
#include "Track.h"
#include "devices/IFXFactory.h"
#include "TrackCommands.h"

/**
 * \brief TrackManager — владелец массива треков и их жизненного цикла.
 *
 * Отвечает за:
 *   - создание/хранение N треков;
 *   - проксирование prepare/reset на все треки;
 *   - привязку пер-трековых буферов (bindBuses) на каждый аудиоблок;
 *   - RT-проход цепочек FX всех треков (processAll);
 *   - применение команд редактирования цепей/параметров между блоками (apply).
 *
 * \par Где живут буферы («bus»)
 *   Пер-трековые аудиобуферы (для DRY и последующей обработки) находятся
 *   на стороне аудиодвижка (AudioEngine). На каждый блок движок формирует
 *   массивы указателей float** L/R (по одному указателю на трек) и вызывает
 *   TrackManager::bindBuses(...), чтобы сообщить трекам «вот ваши рабочие
 *   адреса на этот блок». Треки памятью не владеют и не аллоцируют её.
 *
 * \par Порядок за аудиоблок
 *   1) (между блоками) движок применяет команды → TrackManager::apply(...)
 *   2) движок привязывает буферы → TrackManager::bindBuses(L**, R**, frames)
 *   3) источники рендерят DRY → ITrackSink::addDry(trackId, ...)
 *   4) трековые FX → TrackManager::processAll()  (in-place на привязанных bus)
 *   5) микшер суммирует per-track в мастер → master FX → драйвер
 *
 * \note Все методы, отмеченные как RT, не должны аллоцировать/блокировать/
 *       бросать исключения.
 */
class TrackManager {
public:
    /**
     * \brief Создаёт менеджер с фиксированным количеством треков.
     *
     * \param numTracks  количество треков, которые будут созданы (0..N)
     * \param blockSize  текущий размер аудиоблока (будет передан в prepare)
     * \param registry   фабрика эффектов (не владеем; может быть nullptr)
     *
     * \warning Менеджер не выделяет аудиобуферы — их предоставляет движок.
     */
    TrackManager(int numTracks, int blockSize, IFxRegistry* registry);

    /**
     * \brief Готовит все треки к работе при изменении sample rate / block size.
     *
     * \param sampleRate новый sample rate движка
     * \param blockSize  новый размер блока
     *
     * Вызывается из не-RT кода. Передаёт новые значения всем FX.
     */
    void prepare(int sampleRate, int blockSize);

    /**
     * \brief Сбрасывает состояние всех треков (не-RT).
     *
     * Служебный сброс (транспорт/реинициализация). Памятью bus не управляет.
     */
    void reset();

    // ===================== АУДИО-ЦИКЛ =====================

    /**
     * \brief Привязать пер-трековые буферы на текущий аудиоблок.
     *
     * Движок предоставляет два массива указателей длиной >= numTracks():
     *   - L[i] — float* на левый канал трека i (frames элементов),
     *   - R[i] — float* на правый канал трека i (frames элементов).
     *
     * TrackManager оборачивает эти адреса в TrackBus и передаёт в соответствующий
     * Track::bindBus(...). Далее, когда будет вызван processAll(), цепочки FX
     * треков будут обработаны **in-place** по этим указателям.
     *
     * \param L      массив указателей на левый канал по каждому треку
     * \param R      массив указателей на правый канал по каждому треку
     * \param frames количество сэмплов в текущем блоке (должно совпадать с blockSize)
     *
     * \note Метод RT-безопасен (не аллоцирует/не блокирует). Предполагается,
     *       что сами буферы уже существуют и правильного размера.
     * \note Валидность указателей ограничена одним блоком: на следующем блоке
     *       движок вновь вызывает bindBuses с новыми (или теми же) адресами.
     */
    void bindBuses(float** L, float** R, int frames);

    /**
     * \brief RT-метод: применяет цепочки FX всех треков.
     *
     * Просто вызывает Track::processChain() у каждого трека. Ожидается, что
     * bindBuses уже был вызван и Track’и знают свои рабочие буферы.
     */
    void processAll();

    // ===================== ДОСТУП =====================

    /// Доступ к треку по индексу (без проверок диапазона).
    Track&       track(int i)       { return tracks_[i]; }
    /// Константный доступ к треку по индексу (без проверок диапазона).
    const Track& track(int i) const { return tracks_[i]; }
    /// Количество треков, управляемых менеджером.
    int          numTracks() const  { return (int)tracks_.size(); }

    // ===================== КОМАНДЫ (НЕ RT) =====================

    /**
     * \brief Применяет команду редактирования треков/FX-цепочек.
     *
     * Поддерживаемые команды:
     *   - CmdAddFx      { track, type, index }
     *   - CmdRemoveFx   { track, index }
     *   - CmdMoveFx     { track, from, to }
     *   - CmdSetFxParam { track, index, paramId, value }
     *
     * \return true при успешном применении, false — при ошибке (невалидные
     *         индексы, неизвестный тип FX, отсутствует registry и т.п.)
     *
     * \warning НЕ RT. Вызывайте между аудиоблоками (например, из очереди,
     *          слитой в начале блока).
     */
    bool apply(const TrackCommand& cmd);

private:
    std::vector<Track> tracks_;   ///< собственно треки
    int sr_ = 48000;              ///< текущий sample rate (для prepare FX)
    int bs_ = 64;                 ///< текущий block size (для prepare FX)
    IFxRegistry* registry_ = nullptr; ///< фабрика FX (не владеем; может быть nullptr)
};

